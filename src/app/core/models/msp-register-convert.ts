// Generated by https://quicktype.io
// Generated by https://quicktype.io
// To parse this data:
//
//   import { Convert } from "./file";
//
//   const coordinate = Convert.toCoordinate(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
// tslint:disable-next-line: no-namespace
export namespace Convert {
    export function toCoordinate(json: string): any {
        return cast(JSON.parse(json), 'any');
    }

    export function coordinateToJson(value: any): string {
        return JSON.stringify(uncast(value, 'any'), null, 2);
    }

    function invalidValue(typ: any, val: any): never {
        throw Error(
            `Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(
                typ
            )}`
        );
    }

    function jsonToJSProps(typ: any): any {
        if (typ.jsonToJS === undefined) {
            const map: any = {};
            typ.props.forEach(
                (p: any) => (map[p.json] = { key: p.js, typ: p.typ })
            );
            typ.jsonToJS = map;
        }
        return typ.jsonToJS;
    }

    function jsToJSONProps(typ: any): any {
        if (typ.jsToJSON === undefined) {
            const map: any = {};
            typ.props.forEach(
                (p: any) => (map[p.js] = { key: p.json, typ: p.typ })
            );
            typ.jsToJSON = map;
        }
        return typ.jsToJSON;
    }

    function transform(valc: any, typc: any, getProps: any): any {
        // tslint:disable-next-line: no-shadowed-variable
        function transformPrimitive(typ: string, val: any): any {
            if (typeof typ === typeof val) {
                return val;
            }
            return invalidValue(typ, val);
        }

        // tslint:disable-next-line: no-shadowed-variable
        function transformUnion(typs: any[], val: any): any {
            // val must validate against one typ in typs
            const l = typs.length;
            for (let i = 0; i < l; i++) {
                // tslint:disable-next-line: no-shadowed-variable
                const typ = typs[i];
                try {
                    return transform(val, typ, getProps);
                } catch (_) {}
            }
            return invalidValue(typs, val);
        }

        // tslint:disable-next-line: no-shadowed-variable
        function transformEnum(cases: string[], val: any): any {
            if (cases.indexOf(val) !== -1) {
                return val;
            }
            return invalidValue(cases, val);
        }

        // tslint:disable-next-line: no-shadowed-variable
        function transformArray(typ: any, val: any): any {
            // val must be an array with no invalid elements
            if (!Array.isArray(val)) {
                return invalidValue('array', val);
            }
            return val.map((el) => transform(el, typ, getProps));
        }

        // tslint:disable-next-line: no-shadowed-variable
        function transformDate(typ: any, val: any): any {
            if (val === null) {
                return null;
            }
            const d = new Date(val);
            if (isNaN(d.valueOf())) {
                return invalidValue('Date', val);
            }
            return d;
        }

        // tslint:disable-next-line: no-shadowed-variable
        function transformObject(
            props: { [k: string]: any },
            additional: any,
            val: any
        ): any {
            if (val === null || typeof val !== 'object' || Array.isArray(val)) {
                return invalidValue('object', val);
            }
            const result: any = {};
            Object.getOwnPropertyNames(props).forEach((key) => {
                const prop = props[key];
                const v = Object.prototype.hasOwnProperty.call(val, key)
                    ? val[key]
                    : undefined;
                result[prop.key] = transform(v, prop.typ, getProps);
            });
            Object.getOwnPropertyNames(val).forEach((key) => {
                if (!Object.prototype.hasOwnProperty.call(props, key)) {
                    result[key] = transform(val[key], additional, getProps);
                }
            });
            return result;
        }

        if (typc === 'any') {
            return valc;
        }
        if (typc === null) {
            if (valc === null) {
                return valc;
            }
            return invalidValue(typc, valc);
        }
        if (typc === false) {
            return invalidValue(typc, valc);
        }
        while (typeof typc === 'object' && typc.ref !== undefined) {
            // tslint:disable-next-line: no-use-before-declare
            typc = typeMap[typc.ref];
        }
        if (Array.isArray(typc)) {
            return transformEnum(typc, valc);
        }
        if (typeof typc === 'object') {
            return typc.hasOwnProperty('unionMembers')
                ? transformUnion(typc.unionMembers, valc)
                : typc.hasOwnProperty('arrayItems')
                ? transformArray(typc.arrayItems, valc)
                : typc.hasOwnProperty('props')
                ? transformObject(getProps(typc), typc.additional, valc)
                : invalidValue(typc, valc);
        }
        // Numbers can be parsed by Date but shouldn't be.
        if (typc === Date && typeof valc !== 'number') {
            return transformDate(typc, valc);
        }
        return transformPrimitive(typc, valc);
    }

    function cast<T>(val: any, typ: any): T {
        return transform(val, typ, jsonToJSProps);
    }

    function uncast<T>(val: T, typ: any): any {
        return transform(val, typ, jsToJSONProps);
    }

    function a(typ: any) {
        return { arrayItems: typ };
    }

    function u(...typs: any[]) {
        return { unionMembers: typs };
    }

    function o(props: any[], additional: any) {
        return { props, additional };
    }

    function m(additional: any) {
        return { props: [], additional };
    }

    function r(name: string) {
        return { ref: name };
    }

    const typeMap: any = {};
}
